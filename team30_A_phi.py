import argparse

import dolfinx
import os
import dolfinx.io
import numpy as np
import ufl
from mpi4py import MPI
from petsc4py import PETSc

# Model parameters
mu_0 = 1.25663753e-6  # Relative permability of air
_mu_r = {"Cu": 1, "Strator": 30, "Rotor": 30, "Al": 1, "Air": 1}
_sigma = {"Rotor": 1.6e6, "Al": 3.72e7, "Strator": 0, "Cu": 0, "Air": 0}


# Single phase model domains:
# Copper (0 degrees): 1
# Copper (180 degrees): 2
# Steel strator: 3
# Steel rotor: 4
# Air: 5, 7, 8, 9
# Alu rotor: 6
_domains_single = {"Cu": (1, 2), "Strator": (3,), "Rotor": (4,),
                   "Al": (6,), "Air": (5, 7, 8, 9)}
# Currents on the form J_0 = (0,0, alpha*J*cos(omega*t + beta)) in domain i
_currents_single = {1: {"alpha": 1, "beta": 0}, 2: {"alpha": -1, "beta": 0}}

# Three phase model domains:
# Copper (0 degrees): 1
# Copper (60 degrees): 2
# Copper (120 degrees): 3
# Copper (180 degrees): 4
# Copper (240 degrees): 5
# Copper (300 degrees): 6
# Steel strator: 7
# Steel rotor: 8
# Air: 9, 11, 12, 13, 14, 15, 16, 17
# Alu rotor: 10
_domains_three = {"Cu": (1, 2, 3, 4, 5, 6), "Strator": (7,), "Rotor": (8,),
                  "Al": (10,), "Air": (9, 11, 12, 13, 14, 15, 16, 17)}

# Currents on the form J_0 = (0,0, alpha*J*cos(omega*t + beta)) in domain i
_currents_three = {1: {"alpha": 1, "beta": 0}, 2: {"alpha": -1, "beta": 2 * np.pi / 3},
                   3: {"alpha": 1, "beta": 4 * np.pi / 3}, 4: {"alpha": -1, "beta": 0},
                   5: {"alpha": 1, "beta": 2 * np.pi / 3}, 6: {"alpha": -1, "beta": 4 * np.pi / 3}}

J = 3.1e6  # [A/m^2] Current density of copper winding


def update_current_density(J_0, omega, t, ct, currents):
    """
    Given a DG-0 scalar field J_0, update it to be alpha*J*cos(omega*t + beta)
    in the domains with copper windings
    """
    with J_0.vector.localForm() as j0:
        j0.set(0)
        for domain, values in currents.items():
            _cells = ct.indices[ct.values == domain]
            j0.setValues(
                _cells, np.full(len(_cells), values["alpha"] * np.cos(omega * t + values["beta"])))


def solve_team30(single_phase: bool, T: np.float64, freq: np.float64,
                 form_compiler_parameters: dict = {}, jit_parameters: dict = {}):
    """
    Solve the TEAM 30 problem for a single or three phase engine.
      Parameters
    ==========
    T
        End time of simulation
    freq
        Frequency speed of engine
    single_phase
        If true run the single phase model, otherwise run the three phase model
    form_compiler_parameters
        Parameters used in FFCx compilation of this form. Run `ffcx --help` at
        the commandline to see all available options. Takes priority over all
        other parameter values, except for `scalar_type` which is determined by
        DOLFINx.

    jit_parameters
        Parameters used in CFFI JIT compilation of C code generated by FFCx.
        See `python/dolfinx/jit.py` for all available parameters.
        Takes priority over all other parameter values.
    """
    omega = 2 * np.pi * freq
    dt_ = 0.05 / freq

    if single_phase:
        domains = _domains_single
        currents = _currents_single
        fname = "meshes/single_phase"
    else:
        domains = _domains_three
        currents = _currents_three
        fname = "meshes/three_phase"
        #raise NotImplementedError("Three phase not implemented")

    # Read mesh and cell markers
    with dolfinx.io.XDMFFile(MPI.COMM_WORLD, f"{fname}.xdmf", "r") as xdmf:
        mesh = xdmf.read_mesh(name="Grid")
        ct = xdmf.read_meshtags(mesh, name="Grid")

    # Create DG 0 function for mu_R and sigma
    DG0 = dolfinx.FunctionSpace(mesh, ("DG", 0))
    mu_R = dolfinx.Function(DG0)
    sigma = dolfinx.Function(DG0)
    with mu_R.vector.localForm() as mu_loc, sigma.vector.localForm() as sigma_loc:
        for (material, domain) in domains.items():
            for marker in domain:
                _cells = ct.indices[ct.values == marker]
                data = np.empty(len(_cells), dtype=PETSc.ScalarType)
                data[:] = _mu_r[material]
                mu_loc.setValues(_cells, data)
                data[:] = _sigma[material]
                sigma_loc.setValues(_cells, data)

    dt = dolfinx.Constant(mesh, dt_)
    n = ufl.FacetNormal(mesh)

    # Define problem function space
    cell = mesh.ufl_cell()
    FE = ufl.FiniteElement("Lagrange", cell, 1)
    ME = ufl.MixedElement([FE, FE])
    VQ = dolfinx.FunctionSpace(mesh, ME)

    # Define test, trial and functions for previous timestep
    Az, V = ufl.TrialFunctions(VQ)
    vz, q = ufl.TestFunctions(VQ)
    AnVn = dolfinx.Function(VQ)
    An, Vn = ufl.split(AnVn)  # Solution at previous time step
    J0z = dolfinx.Function(DG0)  # Current density

    # Create integration sets
    Omega_n = domains["Cu"] + domains["Strator"] + domains["Air"]
    Omega_c = domains["Rotor"] + domains["Al"]

    # Create integration measures
    dx_n = ufl.Measure("dx", domain=mesh, subdomain_data=ct, subdomain_id=Omega_n)
    dx_c = ufl.Measure("dx", domain=mesh, subdomain_data=ct, subdomain_id=Omega_c)
    dx_nc = ufl.Measure("dx", domain=mesh, subdomain_data=ct, subdomain_id=Omega_n + Omega_c)
    ds = ufl.Measure("ds", domain=mesh)

    # Define variational form
    a = dt / mu_R * ufl.inner(ufl.grad(Az), ufl.grad(vz)) * dx_nc
    a += dt / mu_R * vz * (n[0] * Az.dx(0) - n[1] * Az.dx(1)) * ds
    a += mu_0 * Az * vz * dx_c
    a += dt * mu_0 * sigma * (V.dx(0) * q.dx(0) + V.dx(1) * q.dx(1)) * dx_c
    L = dt * mu_0 * J0z * vz * dx_n
    L += mu_0 * sigma * An * vz * dx_c

    # Find all dofs in Omega_n for Q-space
    cells_n = np.hstack([ct.indices[ct.values == domain] for domain in Omega_n])
    Q = VQ.sub(1).collapse()
    tdim = mesh.topology.dim
    deac_dofs = dolfinx.fem.locate_dofs_topological((VQ.sub(1), Q), tdim, cells_n)

    # Create zero condition for V in Omega_n
    zeroQ = dolfinx.Function(Q)
    with zeroQ.vector.localForm() as loc:
        loc.set(0)
    bc_Q = dolfinx.DirichletBC(zeroQ, deac_dofs, VQ.sub(1))

    # Create sparsity pattern and matrix with additional non-zeros on diagonal
    cpp_a = dolfinx.Form(a, form_compiler_parameters=form_compiler_parameters,
                         jit_parameters=jit_parameters)._cpp_object
    pattern = dolfinx.cpp.fem.create_sparsity_pattern(cpp_a)
    block_size = VQ.dofmap.index_map_bs
    deac_blocks = deac_dofs[0] // block_size
    pattern.insert_diagonal(deac_blocks)
    pattern.assemble()

    # Create matrix based on sparsity pattern
    A = dolfinx.cpp.la.create_matrix(mesh.mpi_comm(), pattern)
    A.zeroEntries()

    # Create external boundary condition for V space
    V_ = VQ.sub(0).collapse()
    tdim = mesh.topology.dim

    def boundary(x):
        return np.full(x.shape[1], True)

    boundary_facets = dolfinx.mesh.locate_entities_boundary(mesh, tdim - 1, boundary)
    bndry_dofs = dolfinx.fem.locate_dofs_topological((VQ.sub(0), V_), tdim - 1, boundary_facets)
    zeroV = dolfinx.Function(V_)
    with zeroV.vector.localForm() as loc:
        loc.set(0)
    bc_V = dolfinx.DirichletBC(zeroV, bndry_dofs, VQ.sub(0))

    # Assemble matrix once as it is time-independent
    bcs = [bc_V, bc_Q]
    dolfinx.fem.assemble_matrix(A, cpp_a, bcs=bcs)
    A.assemble()

    # Create inital vector for LHS
    cpp_L = dolfinx.Form(L, form_compiler_parameters=form_compiler_parameters,
                         jit_parameters=jit_parameters)._cpp_object
    b = dolfinx.fem.create_vector(cpp_L)

    # Create solver
    solver = PETSc.KSP().create(mesh.mpi_comm())
    solver.setOperators(A)
    solver.setType(PETSc.KSP.Type.PREONLY)
    solver.getPC().setType(PETSc.PC.Type.LU)

    AzV = dolfinx.Function(VQ)

    # Create output file
    xdmf = dolfinx.io.XDMFFile(mesh.mpi_comm(), "results/AzV.xdmf", "w")
    xdmf.write_mesh(mesh)

    # Generate initial electric current in copper windings
    t = 0
    update_current_density(J0z, omega, t, ct, currents)
    while t < T:
        print(t, T)
        # Update time step and current density
        t += dt_
        update_current_density(J0z, omega, t, ct, currents)

        # Reassemble RHS
        b.zeroEntries()
        dolfinx.fem.assemble_vector(b, cpp_L)
        dolfinx.fem.apply_lifting(b, [cpp_a], [bcs])
        b.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)
        dolfinx.fem.set_bc(b, bcs)

        # Solve problem
        solver.solve(b, AzV.vector)
        AzV.x.scatter_forward()

        # Update solution at previous time step
        with AzV.vector.localForm() as loc, AnVn.vector.localForm() as loc_n:
            loc.copy(result=loc_n)

        # Write solution to file
        _Az = AzV.sub(0).collapse()
        _Az.name = "Az"
        _V = AzV.sub(1).collapse()
        _V.name = "V"
        xdmf.write_function(_Az, t)
        xdmf.write_function(_V, t)

    xdmf.close()

    with dolfinx.io.XDMFFile(mesh.mpi_comm(), "results/sigma.xdmf", "w") as xdmf:
        xdmf.write_mesh(mesh)
        xdmf.write_function(sigma)
    with dolfinx.io.XDMFFile(mesh.mpi_comm(), "results/mu_R.xdmf", "w") as xdmf:
        xdmf.write_mesh(mesh)
        xdmf.write_function(mu_R)
    with dolfinx.io.XDMFFile(mesh.mpi_comm(), "results/J0.xdmf", "w") as xdmf:
        xdmf.write_mesh(mesh)
        xdmf.write_function(J0z, 0)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Scripts to  solve the TEAM 30 problem"
        + " (http://www.compumag.org/jsite/images/stories/TEAM/problem30a.pdf)",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    _single = parser.add_mutually_exclusive_group(required=False)
    _single.add_argument('--single', dest='single', action='store_true',
                         help="Generate single phase mesh", default=False)
    _three = parser.add_mutually_exclusive_group(required=False)
    _three.add_argument('--three', dest='three', action='store_true',
                        help="Generate three phase mesh", default=False)
    parser.add_argument("--T", dest='T', type=np.float64, default=0.01, help="End time of simulation")
    parser.add_argument("--freq", dest='freq', type=np.float64, default=1200, help="Rotation speed of engine")

    args = parser.parse_args()

    os.system("mkdir -p results")
    if args.single:
        solve_team30(True, args.T, args.freq)
    if args.three:
        solve_team30(False, args.T, args.freq)
