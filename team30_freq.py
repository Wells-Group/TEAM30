import argparse
import os

import dolfinx
import dolfinx.io
import numpy as np
import tqdm
import ufl
import matplotlib.pyplot as plt
from mpi4py import MPI
from petsc4py import PETSc
from generate_team30_meshes import r2, r3

from utils import PostProcessing

# Model parameters
mu_0 = 1.25663753e-6  # Relative permability of air
freq = 60  # Frequency of excitation
omega_J = 2 * np.pi * freq
J = 3.1e6 * np.sqrt(2)  # [A/m^2] Current density of copper winding

_mu_r = {"Cu": 1, "Stator": 30, "Rotor": 30, "Al": 1, "Air": 1}
_sigma = {"Rotor": 1.6e6, "Al": 3.72e7, "Stator": 0, "Cu": 0, "Air": 0}

# Single phase model domains:
# Copper (0 degrees): 1
# Copper (180 degrees): 2
# Steel Stator: 3
# Steel rotor: 4
# Air: 5, 6, 8, 9, 10
# Alu rotor: 7
_domains_single = {"Cu": (1, 2), "Stator": (3,), "Rotor": (4,),
                   "Al": (7,), "Air": (5, 6, 8, 9, 10)}
# Currents on the form J_0 = (0,0, alpha*J*cos(omega*t + beta)) in domain i
_currents_single = {1: {"alpha": 1, "beta": 0}, 2: {"alpha": 1j, "beta": 0}}
# Domain data for air gap between rotor and windings, MidAir is the tag an internal interface
# AirGap is the domain markers for the domain
_torque_single = {"MidAir": (11,), "restriction": "+", "AirGap": (5, 6)}
# Three phase model domains:
# Copper (0 degrees): 1
# Copper (60 degrees): 2
# Copper (120 degrees): 3
# Copper (180 degrees): 4
# Copper (240 degrees): 5
# Copper (300 degrees): 6
# Steel Stator: 7
# Steel rotor: 8
# Air: 9, 10, 12, 13, 14, 15, 16, 17, 18
# Alu rotor: 11
_domains_three = {"Cu": (1, 2, 3, 4, 5, 6), "Stator": (7,), "Rotor": (8,),
                  "Al": (10,), "Air": (9, 11, 12, 13, 14, 15, 16, 17, 18)}
# Domain data for air gap between rotor and windings, MidAir is the tag an internal interface
# AirGap is the domain markers for the domain
_torque_three = {"MidAir": (19,), "restriction": "+", "AirGap": (9, 10)}
# Currents on the form J_0 = (0,0, alpha*J*cos(omega*t + beta)) in domain i
_currents_three = {1: {"alpha": 1, "beta": 0}, 2: {"alpha": -1, "beta": 2 * np.pi / 3},
                   3: {"alpha": 1, "beta": 4 * np.pi / 3}, 4: {"alpha": -1, "beta": 0},
                   5: {"alpha": 1, "beta": 2 * np.pi / 3}, 6: {"alpha": -1, "beta": 4 * np.pi / 3}}


def solve_team30(single_phase: bool, omega_u: np.float64, degree: np.int32,
                 form_compiler_parameters: dict = {}, jit_parameters: dict = {}):
    """
    Solve the TEAM 30 problem for a single or three phase engine.
      Parameters
    ==========
    single_phase
        If true run the single phase model, otherwise run the three phase model
    omega_u
        Angular speed of rotor
    degree
        Degree of magnetic vector potential functions space
    form_compiler_parameters
        Parameters used in FFCx compilation of this form. Run `ffcx --help` at
        the commandline to see all available options. Takes priority over all
        other parameter values, except for `scalar_type` which is determined by
        DOLFINx.
    jit_parameters
        Parameters used in CFFI JIT compilation of C code generated by FFCx.
        See `python/dolfinx/jit.py` for all available parameters.
        Takes priority over all other parameter values.
    """

    if not PETSc.ScalarType is np.complex128:
        raise RuntimeError("This demo needs complex support.")

    ext = "single" if single_phase else "three"
    fname = f"meshes/{ext}_phase"

    if single_phase:
        domains = _domains_single
        currents = _currents_single
        torque_data = _torque_single
    else:
        domains = _domains_three
        currents = _currents_three
        torque_data = _torque_three

    # Read mesh and cell markers
    with dolfinx.io.XDMFFile(MPI.COMM_WORLD, f"{fname}.xdmf", "r") as xdmf:
        mesh = xdmf.read_mesh(name="Grid")
        ct = xdmf.read_meshtags(mesh, name="Grid")

    # Read facet tag
    tdim = mesh.topology.dim
    mesh.topology.create_connectivity(tdim - 1, 0)
    with dolfinx.io.XDMFFile(MPI.COMM_WORLD, f"{fname}_facets.xdmf", "r") as xdmf:
        ft = xdmf.read_meshtags(mesh, name="Grid")

    # Create DG 0 function for mu_R and sigma
    DG0 = dolfinx.FunctionSpace(mesh, ("DG", 0))
    mu_R = dolfinx.Function(DG0)
    sigma = dolfinx.Function(DG0)
    for (material, domain) in domains.items():
        for marker in domain:
            cells = ct.indices[ct.values == marker]
            mu_R.x.array[cells] = _mu_r[material]
            sigma.x.array[cells] = _sigma[material]

    n = ufl.FacetNormal(mesh)
    # Define problem function space
    cell = mesh.ufl_cell()
    FE = ufl.FiniteElement("Lagrange", cell, 1)
    VQ = dolfinx.FunctionSpace(mesh, FE)

    # Define test, trial and functions for previous timestep
    Az = ufl.TrialFunction(VQ)
    vz = ufl.TestFunction(VQ)
    J0z = dolfinx.Function(DG0)  # Current density

    # Create integration sets
    Omega_n = domains["Cu"] + domains["Stator"] + domains["Air"]
    Omega_c = domains["Rotor"] + domains["Al"]

   # Create integration measures
    dx = ufl.Measure("dx", domain=mesh, subdomain_data=ct)

    # set current density
    for domain, values in currents.items():
        cells = ct.indices[ct.values == domain]
        J0z.x.array[cells] = J * values["alpha"]

    # Define variational form
    a = 1 / mu_R * ufl.inner(ufl.grad(Az), ufl.grad(vz)) * dx(Omega_n)
    a += 1 / mu_R * ufl.inner(ufl.grad(Az), ufl.grad(vz)) * dx(Omega_c)
    a += 1j * omega_J * mu_0 * sigma * ufl.inner(Az, vz) * dx(Omega_c)
    L = mu_0 * ufl.inner(J0z, vz) * dx(Omega_n)

    # # Motion voltage term
    # x = ufl.SpatialCoordinate(mesh)
    # r = ufl.sqrt(x[0]**2 + x[1]**2)
    # theta = ufl.atan_2(x[1], x[0])
    # omega = dolfinx.Constant(mesh, omega_u)
    # u = omega * r * ufl.as_vector((-ufl.sin(theta), ufl.cos(theta)))
    # # a += mu_0 * sigma * ufl.inner(u[0] * Az.dx(0) + u[1] * Az.dx(1), vz) * dx_c

    # Create sparsity pattern and matrix with additional non-zeros on diagonal
    cpp_a = dolfinx.Form(a, form_compiler_parameters=form_compiler_parameters,
                         jit_parameters=jit_parameters)._cpp_object
    pattern = dolfinx.cpp.fem.create_sparsity_pattern(cpp_a)
    pattern.assemble()

    # Create external boundary condition for V space
    tdim = mesh.topology.dim

    # Create matrix based on sparsity pattern
    A = dolfinx.cpp.la.create_matrix(mesh.mpi_comm(), pattern)
    A.zeroEntries()

    def boundary(x):
        return np.full(x.shape[1], True)

    boundary_facets = dolfinx.mesh.locate_entities_boundary(mesh, tdim - 1, boundary)
    bndry_dofs = dolfinx.fem.locate_dofs_topological((VQ, VQ), tdim - 1, boundary_facets)
    zeroV = dolfinx.Function(VQ)
    zeroV.x.array[:] = 0
    bc_V = dolfinx.DirichletBC(zeroV, bndry_dofs, VQ)

    # Assemble matrix once as it is time-harmonic
    bcs = [bc_V]
    dolfinx.fem.assemble_matrix(A, cpp_a, bcs=bcs)
    A.assemble()

    # Create inital vector for LHS
    cpp_L = dolfinx.Form(L, form_compiler_parameters=form_compiler_parameters,
                         jit_parameters=jit_parameters)._cpp_object
    b = dolfinx.fem.create_vector(cpp_L)

    dolfinx.fem.assemble_vector(b, cpp_L)
    dolfinx.fem.apply_lifting(b, [cpp_a], [bcs])
    b.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)
    dolfinx.fem.set_bc(b, bcs)

    # Create solver
    solver = PETSc.KSP().create(mesh.mpi_comm())
    solver.setOperators(A)
    solver.setType(PETSc.KSP.Type.PREONLY)
    solver.getPC().setType(PETSc.PC.Type.LU)

    AzV = dolfinx.Function(VQ)

    solver.solve(b, AzV.vector)
    AzV.x.scatter_forward()

    # AzV.x.array[:] = np.absolute(AzV.x.array[:])
    postproc = PostProcessing(mesh.mpi_comm(), "results/TEAM30_complex")
    postproc.write_mesh(mesh)
    postproc.write_function(AzV, 0, "Az")
    postproc.write_function(sigma, 0, "sigma")
    postproc.write_function(mu_R, 0, "mu_R")

    # Post-processing field
    el_B = ufl.VectorElement("DG", cell, degree - 1)
    VB = dolfinx.FunctionSpace(mesh, el_B)
    ub = ufl.TrialFunction(VB)
    vb = ufl.TestFunction(VB)
    aB = ufl.inner(ub, vb) * ufl.dx
    LB = ufl.inner(ufl.as_vector((AzV.dx(1), AzV.dx(0))), vb) * ufl.dx
    cpp_aB = dolfinx.fem.Form(aB, form_compiler_parameters=form_compiler_parameters, jit_parameters=jit_parameters)
    cpp_LB = dolfinx.fem.Form(LB, form_compiler_parameters=form_compiler_parameters, jit_parameters=jit_parameters)
    AB = dolfinx.fem.assemble_matrix(cpp_aB)
    bB = dolfinx.fem.create_vector(cpp_LB)
    AB.assemble()
    B = dolfinx.Function(VB)
    solverB = PETSc.KSP().create(mesh.mpi_comm())
    solverB.setOperators(AB)
    solverB.setType(PETSc.KSP.Type.PREONLY)
    solverB.getPC().setType(PETSc.PC.Type.LU)

    # Create vector field B
    with bB.localForm() as loc_b:
        loc_b.set(0)
    
    dolfinx.fem.assemble_vector(bB, cpp_LB)
    solverB.solve(bB, B.vector)
    B.x.scatter_forward()
    B.x.array[:] = B.x.array[:]
    postproc.write_function(B, 0, "B")

    postproc.close()

    def cross_2D(A, B):
        return A[0] * B[1] - A[1] * B[0]

    x = ufl.SpatialCoordinate(mesh)
    r = ufl.sqrt(x[0]**2 + x[1]**2)

    # Create variational form for Electromagnetic torque
    Brst = B(torque_data["restriction"])
    dS_air = ufl.Measure("dS", domain=mesh, subdomain_data=ft, subdomain_id=torque_data["MidAir"])
    L = 1
    dF = 1 / mu_0 * (ufl.dot(Brst, x / r) * Brst - 0.5 * ufl.dot(Brst, Brst) * x / r)
    # NOTE: Fake integration over dx to orient normals
    torque = L * cross_2D(x, dF) * dS_air + dolfinx.Constant(mesh, 0) * dx(0)

    # Volume formulation of torque
    # https://www.comsol.com/blogs/how-to-analyze-an-induction-motor-a-team-benchmark-model/
    dx_gap = ufl.Measure("dx", domain=mesh, subdomain_data=ct, subdomain_id=torque_data["AirGap"])
    Bphi = ufl.inner(B, ufl.as_vector((-x[1], x[0]))) / r
    Br = ufl.inner(B, x) / r
    torque_vol = (r * L / (mu_0 * (r3 - r2)) * Br * Bphi) * dx_gap

    T_k = dolfinx.fem.assemble_scalar(torque)
    T_k_vol = dolfinx.fem.assemble_scalar(torque_vol)

    torque = mesh.mpi_comm().allreduce(T_k, op=MPI.SUM)
    torques_vol = mesh.mpi_comm().allreduce(T_k_vol, op=MPI.SUM)

    print(f"RMS Torque: {abs(torque)}")
    print(f"RMS Torque Vol: {abs(torques_vol)}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Scripts to  solve the TEAM 30 problem"
        + " (http://www.compumag.org/jsite/images/stories/TEAM/problem30a.pdf)",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    _single = parser.add_mutually_exclusive_group(required=False)
    _single.add_argument('--single', dest='single', action='store_true',
                         help="Solve single phase problem", default=False)
    _three = parser.add_mutually_exclusive_group(required=False)
    _three.add_argument('--three', dest='three', action='store_true',
                        help="Solve three phase problem", default=False)
    parser.add_argument("--omega", dest='omegaU', type=np.float64, default=600, help="Angular speed of rotor")
    parser.add_argument("--degree", dest='degree', type=np.int32, default=1,
                        help="Degree of magnetic vector potential functions space")
    args = parser.parse_args()

    os.system("mkdir -p results")
    if args.single:
        solve_team30(True, args.omegaU, args.degree)
    if args.three:
        solve_team30(False, args.omegaU, args.degree)
