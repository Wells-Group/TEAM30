from typing import Dict

import dolfinx
import numpy as np
import ufl
from mpi4py import MPI
from petsc4py import PETSc

from generate_team30_meshes import model_parameters, mesh_parameters

__all__ = ["InducedVoltage2D", "LossCalculation2D", "TorqueCalculation2D",
           "MagneticFieldProjection2D", "PostProcessing", "update_current_density"]


def cross_2D(A, B):
    """ Compute cross of two 2D vectors """
    return A[0] * B[1] - A[1] * B[0]


class InducedVoltage2D():

    def __init__(self, AzV: dolfinx.Function, AnVn: dolfinx.Function, L: int,
                 domains: Dict, ct: dolfinx.MeshTags,
                 form_compiler_parameters: Dict = {}, jit_parameters: Dict = {}):
        """
        Compute induced voltage in one of the copper windings

        Parameters
        ==========
        AzV
            The mixed function of the magnetic vector potential Az and the Scalar electric potential V

        AnVn
            The mixed function of the magnetic vector potential Az and the Scalar electric potential V
            from the previous time step

        L
            Depth of domain (in meter)

        domains
            Dictonary were each key indicates a material in the problem. Each item is a tuple of indices relating to the
            volume tags ct and facet tags

        ct
            Meshtag containing cell indices

        form_compiler_parameters
            Parameters used in FFCx compilation of this form. Run `ffcx --help` at
            the commandline to see all available options. Takes priority over all
            other parameter values, except for `scalar_type` which is determined by
            DOLFINx.

        jit_parameters
            Parameters used in CFFI JIT compilation of C code generated by FFCx.
            See `python/dolfinx/jit.py` for all available parameters.
            Takes priority over all other parameter values.
        """
        mesh = AzV.function_space.mesh
        dx = ufl.Measure("dx", domain=mesh, subdomain_data=ct, subdomain_id=domains["Cu"][0])
        self.comm = mesh.mpi_comm()
        N = 1  # number of turns in winding
        S = self.comm.allreduce(dolfinx.fem.assemble_scalar(1 * dx), op=MPI.SUM)

        self.C = len(domains["Cu"]) * N * L / S
        self.dt = dolfinx.Constant(mesh, 0)
        E = (AzV[0] - AnVn[0]) / self.dt
        self._form = dolfinx.fem.Form(E * dx, form_compiler_parameters=form_compiler_parameters,
                                      jit_parameters=jit_parameters)

    def compute_voltage(self, dt):
        """
        Compute induced voltage between two time steps
        """
        self.dt.value = dt
        return self.C * self.comm.allreduce(dolfinx.fem.assemble_scalar(self._form), op=MPI.SUM)


class LossCalculation2D():
    def __init__(self, AzV: dolfinx.Function, AnVn: dolfinx.Function, u: ufl.Form,
                 sigma: dolfinx.Function, domains: Dict, ct: dolfinx.MeshTags,
                 form_compiler_parameters: Dict = {}, jit_parameters: Dict = {}):
        """
        Compute the Loss in the rotor, total and steel component.

        Parameters
        ==========
        AzV
            The mixed function of the magnetic vector potential Az and the Scalar electric potential V

        AnVn
            The mixed function of the magnetic vector potential Az and the Scalar electric potential V
            from the previous time step

        u
            Rotational velocity (Expressed as an ufl expression)

        sigma
            Conductivity

        domains
            Dictonary were each key indicates a material in the problem. Each item is a tuple of indices relating to the
            volume tags ct and facet tags

        ct
            Meshtag containing cell indices

        form_compiler_parameters
            Parameters used in FFCx compilation of this form. Run `ffcx --help` at
            the commandline to see all available options. Takes priority over all
            other parameter values, except for `scalar_type` which is determined by
            DOLFINx.

        jit_parameters
            Parameters used in CFFI JIT compilation of C code generated by FFCx.
            See `python/dolfinx/jit.py` for all available parameters.
            Takes priority over all other parameter values.

        """
        # Induced voltage
        mesh = AzV.function_space.mesh
        dx = ufl.Measure("dx", domain=mesh, subdomain_data=ct)
        self.Az = AzV[0]
        self.Azn = AnVn[0]
        self.dt = dolfinx.Constant(mesh, 0)
        self.comm = mesh.mpi_comm()
        E = (self.Az - self.Azn) / self.dt
        B_2D = ufl.as_vector((self.Az.dx(1), -self.Az.dx(0)))
        Ep = E + cross_2D(u, B_2D)  # NOTE: -ufl.grad(V)=0 in 2D and therefore not included
        al = sigma * ufl.inner(Ep, Ep) * dx(domains["Al"])  # Loss in rotor
        steel = sigma * ufl.inner(Ep, Ep) * dx(domains["Rotor"])  # Loss in only steel
        self._al = dolfinx.fem.Form(al)._cpp_object
        self._steel = dolfinx.fem.Form(steel)._cpp_object

    def compute_loss(self, dt: float) -> float:
        """
        Compute loss between two time steps of distance dt
        """
        self.dt.value = dt
        al = self.comm.allreduce(dolfinx.fem.assemble_scalar(self._al), op=MPI.SUM)
        steel = self.comm.allreduce(dolfinx.fem.assemble_scalar(self._steel), op=MPI.SUM)
        return (al, steel)


class TorqueCalculation2D():
    def __init__(self, AzV: dolfinx.Function, torque_data: Dict, ct: dolfinx.MeshTags, ft: dolfinx.MeshTags,
                 form_compiler_parameters: Dict = {}, jit_parameters: Dict = {}):
        """
        Compute torque induced by magnetic field on the TEAM 30 engine using the surface formulation
        (with Maxwell's stress tensor) or Akkio's method.

        Parameters
        ==========
        AzV
            The mixed function of the magnetic vector potential Az and the Scalar electric potential V

        torque_data
            Dictionary with keys:
            - "MidAir" containing a tuple of markers of the surface integration domain in the middle of the air gap.
            - "AirGap" containing a tuple of markers for integrating the volume air gap in the engine

        ct
            Meshtag containing cell indices

        ft
           Meshtag containing facet inidices

        form_compiler_parameters
            Parameters used in FFCx compilation of this form. Run `ffcx --help` at
            the commandline to see all available options. Takes priority over all
            other parameter values, except for `scalar_type` which is determined by
            DOLFINx.

        jit_parameters
            Parameters used in CFFI JIT compilation of C code generated by FFCx.
            See `python/dolfinx/jit.py` for all available parameters.
            Takes priority over all other parameter values.

        """
        mu_0 = model_parameters["mu_0"]
        mesh = AzV.function_space.mesh
        self.Az = AzV[0]
        self._comm = mesh.mpi_comm()
        x = ufl.SpatialCoordinate(mesh)
        r = ufl.sqrt(x[0]**2 + x[1]**2)
        dx = ufl.Measure("dx", domain=mesh, subdomain_data=ct)
        dS_air = ufl.Measure("dS", domain=mesh, subdomain_data=ft, subdomain_id=torque_data["MidAir"])

        # Create variational form for Electromagnetic torque
        A_res = self.Az(torque_data["restriction"])
        B_2D_rst = ufl.as_vector((A_res.dx(1), -A_res.dx(0)))
        L = 1
        dF = 1 / mu_0 * (ufl.dot(B_2D_rst, x / r) * B_2D_rst - 0.5 * ufl.dot(B_2D_rst, B_2D_rst) * x / r)

        torque_surface = L * cross_2D(x, dF) * dS_air
        torque_surface += dolfinx.Constant(mesh, 0) * dx(0)  # NOTE: Fake integration over dx to orient normals
        self._surface_cpp = dolfinx.fem.Form(torque_surface, form_compiler_parameters=form_compiler_parameters,
                                             jit_parameters=jit_parameters)._cpp_object
        # Volume formulation of torque (Arkkio's method)
        B_2D = ufl.as_vector((self.Az.dx(1), -self.Az.dx(0)))
        Bphi = ufl.inner(B_2D, ufl.as_vector((-x[1], x[0]))) / r
        Br = ufl.inner(B_2D, x) / r
        torque_vol = (r * L / (mu_0 * (mesh_parameters["r3"]
                      - mesh_parameters["r2"])) * Br * Bphi) * dx(torque_data["AirGap"])
        self._volume_cpp = dolfinx.fem.Form(torque_vol, form_compiler_parameters=form_compiler_parameters,
                                            jit_parameters=jit_parameters)._cpp_object

    def torque_surface(self) -> float:
        """
        Compute torque using surface integration in air gap and Maxwell's stress tensor
        """
        return self._comm.allreduce(dolfinx.fem.assemble_scalar(self._surface_cpp), op=MPI.SUM)

    def torque_volume(self) -> float:
        """
        Compute torque using Arrkio's method, derived on Page 55 of:
        "Analysis of induction motors based on the numerical solution of the magnetic field and circuit equations",
        Antero Arkkio, 1987.
        """
        return self._comm.allreduce(dolfinx.fem.assemble_scalar(self._surface_cpp), op=MPI.SUM)


class MagneticFieldProjection2D():
    def __init__(self, AzV: dolfinx.Function,
                 petsc_options: Dict = {}, form_compiler_parameters: Dict = {}, jit_parameters: Dict = {}):
        """
        Class for projecting the magnetic vector potential (here as the first part of the mixed function AvZ)
        to the magnetic flux intensity B=curl(A)

        Parameters
        ==========
        AzV
            The mixed function of the magnetic vector potential Az and the Scalar electric potential V

        petsc_options
            Parameters that is passed to the linear algebra backend PETSc.
            For available choices for the 'petsc_options' kwarg, see the
            `PETSc-documentation <https://www.mcs.anl.gov/petsc/documentation/index.html>`.

        form_compiler_parameters
            Parameters used in FFCx compilation of this form. Run `ffcx --help` at
            the commandline to see all available options. Takes priority over all
            other parameter values, except for `scalar_type` which is determined by
            DOLFINx.

        jit_parameters
            Parameters used in CFFI JIT compilation of C code generated by FFCx.
            See `python/dolfinx/jit.py` for all available parameters.
            Takes priority over all other parameter values.
        """
        degree = AzV.function_space.ufl_element().degree()
        cell = AzV.function_space.ufl_cell()
        mesh = AzV.function_space.mesh

        # Create variational form for electromagnetic field B (post processing)
        el_B = ufl.VectorElement("DG", cell, degree - 1)
        VB = dolfinx.FunctionSpace(mesh, el_B)
        self.B = dolfinx.Function(VB)
        ub = ufl.TrialFunction(VB)
        vb = ufl.TestFunction(VB)
        self.Az = AzV[0]
        a = ufl.inner(ub, vb) * ufl.dx
        B_2D = ufl.as_vector((self.Az.dx(1), -self.Az.dx(0)))
        self._a = dolfinx.fem.Form(a, form_compiler_parameters=form_compiler_parameters, jit_parameters=jit_parameters)
        L = ufl.inner(B_2D, vb) * ufl.dx
        self._L = dolfinx.fem.Form(L, form_compiler_parameters=form_compiler_parameters, jit_parameters=jit_parameters)

        self.A = dolfinx.fem.assemble_matrix(self._a)
        self.A.assemble()
        self.b = dolfinx.fem.create_vector(self._L)

        self.ksp = PETSc.KSP().create(mesh.mpi_comm())
        self.ksp.setOperators(self.A)

        # Set PETSc options
        solver_prefix = "dolfinx_solve_{}".format(id(self))
        self.ksp.setOptionsPrefix(solver_prefix)

        prefix = self.ksp.getOptionsPrefix()
        opts = PETSc.Options()
        opts.prefixPush(prefix)
        for k, v in petsc_options.items():
            opts[k] = v
        opts.prefixPop()
        self.ksp.setFromOptions()

    def solve(self):
        """
        Solve projection problem (only reassemble RHS)
        """
        with self.b.localForm() as loc_b:
            loc_b.set(0)
        dolfinx.fem.assemble_vector(self.b, self._L)
        self.b.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)
        self.ksp.solve(self.b, self.B.vector)
        self.B.x.scatter_forward()


class PostProcessing(dolfinx.io.XDMFFile):
    """
    Post processing class adding a sligth overhead to the XDMFFile class
    """

    def __init__(self, comm: MPI.Intracomm, filename: str):
        super(PostProcessing, self).__init__(comm, f"{filename}.xdmf", "w")

    def write_function(self, u, t, name: str = None):
        if name is not None:
            u.name = name
        super(PostProcessing, self).write_function(u, t)


def update_current_density(J_0, omega, t, ct, currents):
    """
    Given a DG-0 scalar field J_0, update it to be alpha*J*cos(omega*t + beta)
    in the domains with copper windings
    """
    J_0.x.array[:] = 0
    for domain, values in currents.items():
        _cells = ct.indices[ct.values == domain]
        J_0.x.array[_cells] = np.full(len(_cells), model_parameters["J"] * values["alpha"]
                                      * np.cos(omega * t + values["beta"]))
